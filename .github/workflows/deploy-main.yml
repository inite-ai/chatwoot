name: Deploy Chatwoot Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  PROJECT_NAME: chatwoot
  DOMAIN: chat.inite.ai  # Ð—Ð°Ð¼ÐµÐ½Ð¸Ñ‚Ðµ Ð½Ð° Ð²Ð°Ñˆ Ð´Ð¾Ð¼ÐµÐ½
  
jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup project directory
      run: |
        PROJECT_DIR="/opt/projects/${{ env.PROJECT_NAME }}"
        mkdir -p $PROJECT_DIR
        cd $PROJECT_DIR
        
        # Create backup of current deployment if exists
        if [ -d "current" ]; then
          timestamp=$(date +%Y%m%d_%H%M%S)
          mv current backup-$timestamp
        fi
        
        # Create new deployment directory
        mkdir -p current
        cd current
        
        # Copy files to project directory
        cp -r ${{ github.workspace }}/* . 2>/dev/null || true
        cp -r ${{ github.workspace }}/.[^.]* . 2>/dev/null || true

    - name: Setup environment variables
      run: |
        cd /opt/projects/${{ env.PROJECT_NAME }}/current
        
        # Create environment file if it doesn't exist
        if [ ! -f .env ]; then
          cat > .env << EOF
        # Rails Environment
        RAILS_ENV=production
        NODE_ENV=production
        INSTALLATION_ENV=docker

        # Database
        POSTGRES_HOST=postgres
        POSTGRES_PORT=5432
        POSTGRES_DATABASE=chatwoot
        POSTGRES_USERNAME=postgres
        POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}

        # Redis
        REDIS_URL=redis://redis:6379/0
        REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

        # App Configuration
        SECRET_KEY_BASE=${{ secrets.SECRET_KEY_BASE }}
        FRONTEND_URL=https://${{ env.DOMAIN }}

        # Storage
        STORAGE_PROVIDER=local
        STORAGE_BUCKET_NAME=chatwoot

        # Email Configuration
        MAILER_SENDER_EMAIL=chat@inite.ai
        SMTP_DOMAIN=inite.ai
        SMTP_ADDRESS=smtp.mailgun.org
        SMTP_PORT=2525
        SMTP_USERNAME=chat@inite.ai
        SMTP_PASSWORD=${{ secrets.MAIL_PASSWORD }}
        SMTP_AUTHENTICATION=plain
        SMTP_ENABLE_STARTTLS_AUTO=true

        # Facebook
        FB_VERIFY_TOKEN=${{ secrets.FB_VERIFY_TOKEN }}
        FB_APP_SECRET=${{ secrets.FB_APP_SECRET }}
        FB_APP_ID=${{ secrets.FB_APP_ID }}
        FACEBOOK_API_VERSION=v21.0

        # Instagram
        INSTAGRAM_APP_ID=${{ secrets.INSTAGRAM_APP_ID }}
        INSTAGRAM_APP_SECRET=${{ secrets.INSTAGRAM_APP_SECRET }}
        INSTAGRAM_VERIFY_TOKEN=${{ secrets.INSTAGRAM_VERIFY_TOKEN }}
        INSTAGRAM_API_VERSION=v22.0

        # Google OAuth (Gmail)
        GOOGLE_OAUTH_CLIENT_ID=${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}
        GOOGLE_OAUTH_CLIENT_SECRET=${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}
        GOOGLE_OAUTH_REDIRECT_URI=https://${{ env.DOMAIN }}/google/callback

        # Microsoft OAuth (Outlook/Office 365)
        AZURE_APP_ID=${{ secrets.AZURE_APP_ID }}
        AZURE_APP_SECRET=${{ secrets.AZURE_APP_SECRET }}

        # WhatsApp
        WHATSAPP_APP_ID=${{ secrets.WHATSAPP_APP_ID }}
        WHATSAPP_APP_SECRET=${{ secrets.WHATSAPP_APP_SECRET }}
        WHATSAPP_CONFIGURATION_ID=${{ secrets.WHATSAPP_CONFIGURATION_ID }}
        WHATSAPP_API_VERSION=v21.0

        # Telegram
        TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}

        # SMS Channels
        TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}
        TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}

        # Enterprise Configuration
        IS_ENTERPRISE=true
        INSTALLATION_PRICING_PLAN=enterprise
        DEPLOYMENT_ENV=docker
        
        # Captain AI Configuration (Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾)
        CAPTAIN_OPEN_AI_API_KEY=${{ secrets.CAPTAIN_OPEN_AI_API_KEY }}
        CAPTAIN_OPEN_AI_MODEL=gpt-4o-mini
        CAPTAIN_OPEN_AI_ENDPOINT=https://api.openai.com/
        CAPTAIN_EMBEDDING_MODEL=text-embedding-3-small
        CAPTAIN_OPEN_AI_ORGANIZATION=${{ secrets.CAPTAIN_OPEN_AI_ORGANIZATION }}
        CAPTAIN_FIRECRAWL_API_KEY=${{ secrets.CAPTAIN_FIRECRAWL_API_KEY }}

        # Additional configuration
        RAILS_LOG_TO_STDOUT=true
        USE_INBOX_AVATAR_FOR_BOT=true
        EOF
        fi

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Set up Docker Buildx
      id: buildx
      uses: docker/setup-buildx-action@v3
      continue-on-error: true

    - name: Build and push Docker image (with Buildx)
      if: steps.buildx.outcome == 'success'
      uses: docker/build-push-action@v5
      with:
        context: /opt/projects/${{ env.PROJECT_NAME }}/current
        file: /opt/projects/${{ env.PROJECT_NAME }}/current/docker/Dockerfile
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.PROJECT_NAME }}:latest
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          RAILS_ENV=production
          NODE_ENV=production
          NODE_OPTIONS=--max-old-space-size=4096

    - name: Build and push Docker image (fallback)
      if: steps.buildx.outcome == 'failure'
      run: |
        cd /opt/projects/${{ env.PROJECT_NAME }}/current
        
        # Fallback to traditional docker build without BuildKit
        export DOCKER_BUILDKIT=0
        
        # Build the image with production settings
        docker build \
          --build-arg RAILS_ENV=production \
          --build-arg NODE_ENV=production \
          --build-arg NODE_OPTIONS=--max-old-space-size=4096 \
          -f docker/Dockerfile \
          -t ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.PROJECT_NAME }}:latest .
        
        docker push ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.PROJECT_NAME }}:latest

    - name: Create production docker-compose
      run: |
        cd /opt/projects/${{ env.PROJECT_NAME }}/current
        
        # Create production docker-compose with external network
        cat > docker-compose.prod.yml << EOF
        version: '3.8'
        
        # ÐžÐ±Ñ‰Ð¸Ð¹ template Ð´Ð»Ñ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ (YAML anchor)
        x-chatwoot-environment: &chatwoot-environment
          RAILS_ENV: production
          NODE_ENV: production
          INSTALLATION_ENV: docker
          POSTGRES_HOST: postgres
          POSTGRES_PORT: 5432
          POSTGRES_DATABASE: chatwoot
          POSTGRES_USERNAME: postgres
          POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_URL: redis://redis:6379/0
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
          FRONTEND_URL: https://${{ env.DOMAIN }}
          MAILER_SENDER_EMAIL: chat@inite.ai
          SMTP_DOMAIN: inite.ai
          SMTP_ADDRESS: smtp.mailgun.org
          SMTP_PORT: 2525
          SMTP_USERNAME: chat@inite.ai
          SMTP_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          SMTP_AUTHENTICATION: plain
          SMTP_ENABLE_STARTTLS_AUTO: true
          FB_VERIFY_TOKEN: ${{ secrets.FB_VERIFY_TOKEN }}
          FB_APP_SECRET: ${{ secrets.FB_APP_SECRET }}
          FB_APP_ID: ${{ secrets.FB_APP_ID }}
          FACEBOOK_API_VERSION: v21.0
          INSTAGRAM_APP_ID: ${{ secrets.INSTAGRAM_APP_ID }}
          INSTAGRAM_APP_SECRET: ${{ secrets.INSTAGRAM_APP_SECRET }}
          INSTAGRAM_VERIFY_TOKEN: ${{ secrets.INSTAGRAM_VERIFY_TOKEN }}
          INSTAGRAM_API_VERSION: v22.0
          GOOGLE_OAUTH_CLIENT_ID: ${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}
          GOOGLE_OAUTH_CLIENT_SECRET: ${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}
          GOOGLE_OAUTH_REDIRECT_URI: https://${{ env.DOMAIN }}/google/callback
          AZURE_APP_ID: ${{ secrets.AZURE_APP_ID }}
          AZURE_APP_SECRET: ${{ secrets.AZURE_APP_SECRET }}
          WHATSAPP_APP_ID: ${{ secrets.WHATSAPP_APP_ID }}
          WHATSAPP_APP_SECRET: ${{ secrets.WHATSAPP_APP_SECRET }}
          WHATSAPP_CONFIGURATION_ID: ${{ secrets.WHATSAPP_CONFIGURATION_ID }}
          WHATSAPP_API_VERSION: v21.0
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          IS_ENTERPRISE: true
          INSTALLATION_PRICING_PLAN: enterprise
          DEPLOYMENT_ENV: docker
          CAPTAIN_OPEN_AI_API_KEY: ${{ secrets.CAPTAIN_OPEN_AI_API_KEY }}
          CAPTAIN_OPEN_AI_MODEL: gpt-4o-mini
          CAPTAIN_OPEN_AI_ENDPOINT: https://api.openai.com/
          CAPTAIN_EMBEDDING_MODEL: text-embedding-3-small
          CAPTAIN_OPEN_AI_ORGANIZATION: ${{ secrets.CAPTAIN_OPEN_AI_ORGANIZATION }}
          CAPTAIN_FIRECRAWL_API_KEY: ${{ secrets.CAPTAIN_FIRECRAWL_API_KEY }}
          RAILS_LOG_TO_STDOUT: true
          USE_INBOX_AVATAR_FOR_BOT: true

        services:
          rails:
            image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.PROJECT_NAME }}:latest
            container_name: ${{ env.PROJECT_NAME }}-rails
            restart: unless-stopped
            expose:
              - "3000"
            deploy:
              resources:
                limits:
                  memory: 2G
                reservations:
                  memory: 1G
            environment:
              <<: *chatwoot-environment
            volumes:
              - chatwoot_storage:/app/storage
              - chatwoot_public:/app/public
            depends_on:
              postgres:
                condition: service_healthy
              redis:
                condition: service_healthy
            entrypoint: docker/entrypoints/rails.sh
            command: ['bundle', 'exec', 'rails', 's', '-p', '3000', '-b', '0.0.0.0']
            labels:
              - "traefik.enable=true"
              - "traefik.http.routers.${{ env.PROJECT_NAME }}.rule=Host(\`${{ env.DOMAIN }}\`)"
              - "traefik.http.routers.${{ env.PROJECT_NAME }}.entrypoints=websecure"
              - "traefik.http.routers.${{ env.PROJECT_NAME }}.tls=true"
              - "traefik.http.routers.${{ env.PROJECT_NAME }}.tls.certresolver=letsencrypt"
              - "traefik.http.services.${{ env.PROJECT_NAME }}.loadbalancer.server.port=3000"
              - "traefik.docker.network=traefik-global"
              # Redirect HTTP to HTTPS
              - "traefik.http.routers.${{ env.PROJECT_NAME }}-http.rule=Host(\`${{ env.DOMAIN }}\`)"
              - "traefik.http.routers.${{ env.PROJECT_NAME }}-http.entrypoints=web"
              - "traefik.http.routers.${{ env.PROJECT_NAME }}-http.middlewares=redirect-to-https"
              - "traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https"
              - "traefik.http.middlewares.redirect-to-https.redirectscheme.permanent=true"
            networks:
              - chatwoot-network
              - traefik-global

          sidekiq:
            image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.PROJECT_NAME }}:latest
            container_name: ${{ env.PROJECT_NAME }}-sidekiq
            restart: unless-stopped
            deploy:
              resources:
                limits:
                  memory: 512M
                reservations:
                  memory: 256M
            environment:
              <<: *chatwoot-environment
            volumes:
              - chatwoot_storage:/app/storage
              - chatwoot_public:/app/public
            depends_on:
              postgres:
                condition: service_healthy
              redis:
                condition: service_healthy
            command: ['bundle', 'exec', 'sidekiq', '-C', 'config/sidekiq.yml']
            networks:
              - chatwoot-network

          redis:
            image: redis:7-alpine
            container_name: ${{ env.PROJECT_NAME }}-redis
            restart: unless-stopped
            command: ["sh", "-c", "redis-server --requirepass \\"${{ secrets.REDIS_PASSWORD }}\\""]
            volumes:
              - chatwoot_redis:/data
            networks:
              - chatwoot-network
            healthcheck:
              test: [ "CMD", "redis-cli", "-a", "${{ secrets.REDIS_PASSWORD }}", "ping" ]
              interval: 10s
              timeout: 5s
              retries: 5

          postgres:
            image: pgvector/pgvector:pg16
            container_name: ${{ env.PROJECT_NAME }}-postgres
            restart: unless-stopped
            environment:
              POSTGRES_DB: chatwoot
              POSTGRES_USER: postgres
              POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
            volumes:
              - chatwoot_postgres:/var/lib/postgresql/data
            networks:
              - chatwoot-network
            healthcheck:
              test: [ "CMD-SHELL", "pg_isready -U postgres" ]
              interval: 10s
              timeout: 5s
              retries: 5

        networks:
          chatwoot-network:
            driver: bridge
          traefik-global:
            external: true

        volumes:
          chatwoot_postgres:
            driver: local
          chatwoot_redis:
            driver: local
          chatwoot_storage:
            driver: local
          chatwoot_public:
            driver: local
        EOF

    - name: Deploy application
      run: |
        cd /opt/projects/${{ env.PROJECT_NAME }}/current
        
        echo "ðŸš€ Deploying Chatwoot with Traefik integration..."
        
        # Set unique project name to avoid conflicts with other Docker Compose projects
        export COMPOSE_PROJECT_NAME=chatwoot-prod
        
        # Pull latest images
        docker-compose -f docker-compose.prod.yml pull || true
        
        # Stop and remove old containers
        docker-compose -f docker-compose.prod.yml down --remove-orphans || true
        
        # Start new containers
        docker-compose -f docker-compose.prod.yml up -d
        
        # Restart Traefik to pick up new container
        echo "ðŸ”„ Restarting Traefik to pick up new routes..."
        docker restart traefik-global || true
        
        # Force refresh Docker networks
        echo "ðŸ”— Refreshing Docker networks..."
        docker network disconnect traefik-global chatwoot-rails 2>/dev/null || true
        docker network connect traefik-global chatwoot-rails || true
        
        # Wait for services to be ready
        echo "â³ Waiting for services to start..."
        sleep 30
        
        # Check database connection and run migrations
        echo "ðŸ”„ Running database migrations..."
        COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails db:create || true
        
        # Run migrations in smaller chunks to avoid memory issues
        echo "ðŸ”„ Running database migrations (optimized)..."
        
        # First, check if migration is needed
        if COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails db:version 2>/dev/null | grep -q "Current version: 0"; then
          echo "Running initial schema load instead of migrations..."
          COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails db:schema:load || {
            echo "Schema load failed, trying step-by-step migrations..."
            COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails db:migrate:up VERSION=20230426130150
          }
        else
          echo "Running incremental migrations..."
          COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails db:migrate
        fi
        
        # Run seeds only on initial deployment (check if admin user already exists)
        echo "ðŸŒ± Running database seeds (if needed)..."
        if COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails runner "puts User.where(type: 'SuperAdmin').exists?" | grep -q "false"; then
          echo "No admin user found, running seeds..."
          COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails db:seed || true
        else
          echo "Admin user exists, skipping seeds to avoid onboarding reset"
        fi
        
        # Set correct pricing plan for Enterprise
        echo "ðŸ’Ž Setting Enterprise pricing plan..."
        COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails runner "
        config = InstallationConfig.find_or_initialize_by(name: 'INSTALLATION_PRICING_PLAN')
        old_value = config.value
        config.value = 'enterprise'
        config.locked = false
        config.save!
        GlobalConfig.clear_cache
        puts \"Updated INSTALLATION_PRICING_PLAN: #{old_value} â†’ enterprise\"
        " || true
        
        # Enable Captain AI feature for all accounts
        echo "ðŸ¤– Enabling Captain AI for all accounts..."
        COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails runner "
        # Check Enterprise status
        puts \"Enterprise mode: #{ChatwootApp.enterprise?}\"
        puts \"Installation pricing plan: #{GlobalConfig.get('INSTALLATION_PRICING_PLAN')}\"
        puts \"Is Enterprise config: #{ENV['IS_ENTERPRISE']}\"
        
        Account.find_each do |account|
          puts \"Processing account: #{account.name} (ID: #{account.id})\"
          puts \"Current features: #{account.all_features}\"
          
          # Enable captain_integration feature
          unless account.feature_enabled?('captain_integration')
            account.enable_features!('captain_integration')
            puts \"âœ… Enabled captain_integration for: #{account.name}\"
          else
            puts \"â„¹ï¸ captain_integration already enabled for: #{account.name}\"
          end
          
          # Also try enabling captain feature (alternative name)
          begin
            unless account.feature_enabled?('captain')
              account.enable_features!('captain')
              puts \"âœ… Enabled captain for: #{account.name}\"
            else
              puts \"â„¹ï¸ captain already enabled for: #{account.name}\"
            end
          rescue => e
            puts \"âš ï¸ Could not enable captain feature: #{e.message}\"
          end
          
          puts \"Final features: #{account.all_features}\"
          puts \"---\"
        end
        puts 'ðŸŽ‰ Captain AI enablement completed!'
        " || true
        
        # Fix OpenAI Organization ID for project-based keys
        echo "ðŸ”§ Applying OpenAI Project Keys patch..."
        COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails runner /app/fix_openai_project_keys.rb || true
        
        # Precompile assets in production
        echo "ðŸŽ¨ Precompiling assets..."
        COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails assets:precompile || true
        
        # Check if services are running
        if COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml ps | grep -q "Up"; then
          echo "âœ… Deployment successful!"
          echo "ðŸŒ Service available at: https://${{ env.DOMAIN }}"
          
          # Show service status
          COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml ps
        else
          echo "âŒ Deployment failed!"
          echo "ðŸ“‹ Container logs:"
          COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml logs --tail=50
          exit 1
        fi

    - name: Health check
      run: |
        cd /opt/projects/${{ env.PROJECT_NAME }}/current
        
        # Wait a bit more for full startup
        sleep 10
        
        # Basic health check
        if curl -f -s -o /dev/null https://${{ env.DOMAIN }}/api/v1/accounts; then
          echo "âœ… Application is responding correctly"
        else
          echo "âš ï¸  Application might not be fully ready yet"
          echo "ðŸ“‹ Recent logs:"
          COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml logs --tail=20 rails
          
          # Try internal health check
          echo "ðŸ” Trying internal health check..."
          COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails curl -f http://localhost:3000/api/v1/accounts || true
        fi
        
        # Post-deployment Captain AI verification
        echo "ðŸ” Verifying Captain AI status..."
        COMPOSE_PROJECT_NAME=chatwoot-prod docker-compose -f docker-compose.prod.yml exec -T rails bundle exec rails runner "
        puts '=== Captain AI Status Check ==='
        puts \"Enterprise mode: #{ChatwootApp.enterprise?}\"
        puts \"IS_ENTERPRISE: #{ENV['IS_ENTERPRISE']}\"
        puts \"Captain API Key: #{ENV['CAPTAIN_OPEN_AI_API_KEY'].present? ? 'Present' : 'Missing'}\"
        
        Account.limit(3).each do |account|
          puts \"Account #{account.name}: captain_integration=#{account.feature_enabled?('captain_integration')}\"
        end
        puts '==========================='
        " || true

    - name: Cleanup
      run: |
        # Clean up unused Docker images
        docker system prune -f
        
        # Clean up old project backups (keep last 3 deployments)
        find /opt/projects/${{ env.PROJECT_NAME }} -name "backup-*" -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true
        
        echo "ðŸ§¹ Cleanup completed"

